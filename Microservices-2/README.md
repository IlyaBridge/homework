#  «Создание собственных модулей» "`«Микросервисы: принципы»`" - `Казначеев Илья`

https://github.com/netology-code/micros-homeworks/blob/main/11-microservices-02-principles.md

---

# Задача 1: API Gateway
Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу возможностей различных программных решений. На основе таблицы сделайте выбор решения.

Решение должно соответствовать следующим требованиям:

маршрутизация запросов к нужному сервису на основе конфигурации,
возможность проверки аутентификационной информации в запросах,
обеспечение терминации HTTPS.
Обоснуйте свой выбор.

# Решение 1

## Сравнительная таблица решений для API Gateway

**Цель:** Выбор решения для крупной компании с микросервисной архитектурой.
**Ключевые требования:** Маршрутизация, аутентификация, терминация HTTPS, надежность, простота эксплуатации.

| Критерий | [NGINX (Open Source)](https://nginx.org/ru/) | [NGINX Plus](https://www.f5.com/go/product/welcome-to-nginx) | [Kong](https://konghq.com/products/kong-gateway) | [Traefik](https://traefik.io/traefik/) |
| :--- | :--- | :--- | :--- | :--- |
| **Маршрутизация запросов** | Базовая, на основе конфиг-файлов | Продвинутая, с API для динамической конфигурации | Динамическая, через REST API или декларативно | Динамическая, автоматическая из сервисного обнаружения (Kubernetes, Docker) |
| **Проверка аутентификации** | Требует ручной настройки (e.g., через `auth_request`), сложно | Встроенные JWT проверки, возможность интеграции | **Богатая встроенная поддержка** (JWT, Key-Auth, OAuth2.0, LDAP через плагины) | Basic Auth, Digest Auth, через промежуточное ПО (Middleware) |
| **Терминация HTTPS** | **Эталонная реализация**, высочайшая производительность | + Управление сертификатами через API | Полная поддержка, управление через Admin API | Полная поддержка, автоматическое получение сертификатов (Let's Encrypt) |
| **Производительность** | **Очень высокая** (C, event-driven) | Очень высокая | Высокая (на основе NGINX) | Высокая (на Go) |
| **Кластеризация и HA** | Требует ручной настройки | Встроенная актив-актив кластеризация | **Встроенная через базу данных** (PostgreSQL/Cassandra) | Хранит состояние в backend (Kubernetes, etcd) |
| **Экосистема и плагины** | Ограничена, требует программирования на Lua | Стабильный набор плагинов | **Огромное сообщество, множество готовых плагинов** | Много встроенных Middleware, гибкая система провайдеров |
| **Управление конфигурацией** | Статичные файлы, сложность при росте | Динамический API, GUI-панель | **REST API, декларативный config, GUI (Kong Manager)** | Через провайдеров (labels в Docker, CRD в Kubernetes) |
| **Поддержка** | Сообщество | **Прямая коммерческая от NGINX/F5** | Коммерческая поддержка (Kong Inc.) / Сообщество | Коммерческая поддержка (Traefik Enterprise) / Сообщество |

**Вывод:** Для крупной компании с микросервисной архитектурой рекомендуется **Kong** как решение, наиболее полно соответствующее требованиям и обеспечивающее лучший баланс функциональности, производительности и простоты эксплуатации.

---

## Задача 2: Брокер сообщений
Составьте таблицу возможностей различных брокеров сообщений. На основе таблицы сделайте обоснованный выбор решения.

Решение должно соответствовать следующим требованиям:

поддержка кластеризации для обеспечения надёжности,
хранение сообщений на диске в процессе доставки,
высокая скорость работы,
поддержка различных форматов сообщений,
разделение прав доступа к различным потокам сообщений,
простота эксплуатации.
Обоснуйте свой выбор.


## Решение 2

# Сравнительная таблица брокеров сообщений

| Критерий / Решение | **RabbitMQ** | **Apache Kafka** | **NATS** (с JetStream) | **AWS SQS/SNS** (Managed) |
| :--- | :--- | :--- | :--- | :--- |
| **Кластеризация и надежность** | **Отличная** (зеркалированные очереди) | **Великолепная** (партиционирование, репликация) | Хорошая (Raft consensus) | Полностью управляемый сервис, высочайшая надежность |
| **Хранение сообщений на диске** | **Да (по желанию)** Сообщения могут быть персистентными | **Да (обязательно)** Хранит все сообщения топика | Да (включено опцией JetStream) | Да (управляется AWS) |
| **Скорость работы** | Очень высокая | **Экстремально высокая** на больших объемах | **Максимальная** (легковесный протокол) | Высокая (зависит от региона и нагрузки AWS) |
| **Поддержка форматов сообщений** | Любые (бинарные, текст, JSON, etc.) | Любые (бинарный blob) | Любые (бинарные, текст, JSON) | Любые (текст, JSON) |
| **Разделение прав доступа** | **Богатая модель** (VHost, пользователи, права на чтение/запись) | На основе SSL/SASL, ACL | Базовая (авторизация, аутентификация) | Интеграция с IAM AWS (очень гибко) |
| **Простота эксплуатации** | Средняя (требует понимания моделей) | **Высокая сложность** | Низкая (простой бинарный протокол) | **Максимальная** (полностью managed) |
| **Модель доставки** | Точка-точка (Queues), Pub/Sub (Exchanges) | Pub/Sub (логирование потоков) | Pub/Sub, Point-to-Point | Точка-точка (SQS), Pub/Sub (SNS) |
| **Идеальный сценарий** | Фоновые задачи, оркестрация, сложная маршрутизация | Потоковая обработка данных, event sourcing, логгирование | Сервисное взаимодействие, IoT, высокая пропускная способность | Компании в экосистеме AWS, где нужно минимизировать ops нагрузку |

**Вывод:** Для обеспечения надежности, гибкости и простоты эксплуатации в микросервисной архитектуре рекомендуется **RabbitMQ** как наиболее сбалансированное и проверенное решение.

---